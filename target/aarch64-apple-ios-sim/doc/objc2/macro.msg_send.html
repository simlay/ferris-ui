<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Send a message to an object or class."><title>msg_send in objc2 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="objc2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (b925a865e 2025-10-09)" data-channel="nightly" data-search-js="search-8d3311b9.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">msg_send</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../objc2/index.html">objc2</a><span class="version">0.6.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">msg_<wbr>send</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#memory-management" title="Memory management">Memory management</a><ul><li><a href="#a-little-history" title="A little history">A little history</a></li></ul></li><li><a href="#specification" title="Specification">Specification</a><ul><li><a href="#memory-management-details" title="Memory management details">Memory management details</a></li></ul></li><li><a href="#bool-handling" title="`bool` handling"><code>bool</code> handling</a></li><li><a href="#out-parameters" title="Out-parameters">Out-parameters</a></li><li><a href="#errors" title="Errors">Errors</a></li><li><a href="#panics" title="Panics">Panics</a><ul><li><a href="#type-verification" title="Type verification">Type verification</a></li></ul></li><li><a href="#safety" title="Safety">Safety</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate objc2</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">objc2</a></div><h1>Macro <span class="macro">msg_<wbr>send</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/objc2/macros/mod.rs.html#1196-1239">Source</a> </span></div><pre class="rust item-decl"><code>macro_rules! msg_send {
    [super($obj:expr), $($selector_and_arguments:tt)+] =&gt; { ... };
    [super($obj:expr, $superclass:expr), $($selector_and_arguments:tt)+] =&gt; { ... };
    [$obj:expr, $($selector_and_arguments:tt)+] =&gt; { ... };
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Send a message to an object or class.</p>
<p>This is wildly <code>unsafe</code>, even more so than sending messages in
Objective-C, because this macro can’t inspect header files to see the
expected types, and because Rust has more safety invariants to uphold.
Make sure to review the safety section below!</p>
<p>The recommended way of using this macro is by defining a wrapper function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">unsafe fn </span>do_something(obj: <span class="kw-2">&amp;</span>NSObject, arg: c_int) -&gt; <span class="kw-2">*const </span>c_char {
    <span class="macro">msg_send!</span>[obj, doSomething: arg]
}</code></pre></div>
<p>This way we are clearly communicating to Rust that: The method
<code>doSomething:</code> works with a shared reference to the object. It takes a
C-style signed integer, and returns a pointer to what is probably a
C-compatible string. Now it’s much, <em>much</em> easier to make a safe
abstraction around this!</p>
<p>The <a href="macro.extern_methods.html" title="macro objc2::extern_methods"><code>extern_methods!</code></a> macro can help with coding this pattern.</p>
<h2 id="memory-management"><a class="doc-anchor" href="#memory-management">§</a>Memory management</h2>
<p>If an Objective-C method returns <code>id</code>, <code>NSObject*</code>, or similar object
pointers, you should use <a href="rc/struct.Retained.html" title="struct objc2::rc::Retained"><code>Retained&lt;T&gt;</code></a> on the Rust side, or
<code>Option&lt;Retained&lt;T&gt;&gt;</code> if the pointer is nullable.</p>
<p>This is necessary because object pointers in Objective-C have certain
rules for when they should be retained and released across function calls.</p>
<h3 id="a-little-history"><a class="doc-anchor" href="#a-little-history">§</a>A little history</h3>
<p>Objective-C’s type system is… limited, so you can’t tell without
consulting the documentation who is responsible for releasing an object.
To remedy this problem, Apple/Cocoa introduced (approximately) the
following rule:</p>
<p>The caller is responsible for releasing objects return from methods that
begin with <code>new</code>, <code>alloc</code>, <code>copy</code>, <code>mutableCopy</code> or <code>init</code>, and method
that begins with <code>init</code> takes ownership of the receiver. See <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1">Cocoa’s
Memory Management Policy</a> for a user-friendly introduction to
this concept.</p>
<p>In the past, users had to do <code>retain</code> and <code>release</code> calls themselves to
properly follow these rules. To avoid the memory management problems
associated with manual stuff like that, they <a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226">introduced “ARC”</a>,
which codifies the rules as part of the language, and inserts the required
<code>retain</code> and <code>release</code> calls automatically.</p>
<p>Returning a <code>*const T</code> pointer is similar to pre-ARC; you have to know
when to retain and when to release an object. Returning <code>Retained</code> is
similar to ARC; the rules are simple enough that we can do them
automatically!</p>
<h2 id="specification"><a class="doc-anchor" href="#specification">§</a>Specification</h2>
<p>The syntax is somewhat similar to the message syntax in Objective-C,
except with a comma between arguments. Eliding the comma is possible, but
deprecated, and may be removed in a future version of <code>objc2</code>.</p>
<p>The first expression, know as the “receiver”, can be any type that
implements <a href="runtime/trait.MessageReceiver.html" title="trait objc2::runtime::MessageReceiver"><code>MessageReceiver</code></a>, like a reference or a pointer to an
object. Additionally, it can even be a reference to an <a href="rc/struct.Retained.html" title="struct objc2::rc::Retained"><code>Retained</code></a>
containing an object.</p>
<p>The expression can be wrapped in <code>super</code>, with an optional superclass
as the second argument. If no specific superclass is specified, the
direct superclass is retrieved from <a href="trait.ClassType.html" title="trait objc2::ClassType"><code>ClassType</code></a>.</p>
<p>All arguments, as well as the return type, must implement <a href="encode/trait.Encode.html" title="trait objc2::encode::Encode"><code>Encode</code></a> (bar
the exceptions below).</p>
<p>If the last argument is the special marker <code>_</code>, the macro will return a
<code>Result&lt;_, Retained&lt;E&gt;&gt;</code>, see below.</p>
<p>This macro roughly translates into a call to <a href="macro.sel.html" title="macro objc2::sel"><code>sel!</code></a>, and afterwards a
fully qualified call to <a href="runtime/trait.MessageReceiver.html#method.send_message" title="method objc2::runtime::MessageReceiver::send_message"><code>MessageReceiver::send_message</code></a>. Note that this
means that auto-dereferencing of the receiver is not supported, and that
the receiver is consumed. You may encounter a little trouble with <code>&amp;mut</code>
references, try refactoring into a separate method or reborrowing the
reference.</p>
<p>Variadic arguments are currently not supported.</p>
<h3 id="memory-management-details"><a class="doc-anchor" href="#memory-management-details">§</a>Memory management details</h3>
<p>The accepted receiver and return types, and how we handle them, differ
depending on which, if any, of the <a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-method-families">recognized selector
families</a> the selector belongs to:</p>
<ul>
<li>
<p>The <code>new</code> family: The receiver may be anything that implements
<a href="runtime/trait.MessageReceiver.html" title="trait objc2::runtime::MessageReceiver"><code>MessageReceiver</code></a> (though often you’ll want to use <code>&amp;AnyClass</code>). The
return type is a generic <code>Retained&lt;T&gt;</code> or <code>Option&lt;Retained&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>The <code>alloc</code> family: The receiver must be <code>&amp;AnyClass</code>, and the return
type is a generic <code>Allocated&lt;T&gt;</code>.</p>
</li>
<li>
<p>The <code>init</code> family: The receiver must be <code>Allocated&lt;T&gt;</code> as returned from
<code>alloc</code>, or if sending messages to the superclass, it must be
<code>PartialInit&lt;T&gt;</code>.</p>
<p>The receiver is consumed, and a the now-initialized <code>Retained&lt;T&gt;</code> or
<code>Option&lt;Retained&lt;T&gt;&gt;</code> (with the same <code>T</code>) is returned.</p>
</li>
<li>
<p>The <code>copy</code> family: The receiver may be anything that implements
<a href="runtime/trait.MessageReceiver.html" title="trait objc2::runtime::MessageReceiver"><code>MessageReceiver</code></a> and the return type is a generic <code>Retained&lt;T&gt;</code> or
<code>Option&lt;Retained&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>The <code>mutableCopy</code> family: Same as the <code>copy</code> family.</p>
</li>
<li>
<p>No family: The receiver may be anything that implements
<a href="runtime/trait.MessageReceiver.html" title="trait objc2::runtime::MessageReceiver"><code>MessageReceiver</code></a>. The result is retained using
<a href="rc/struct.Retained.html#method.retain_autoreleased" title="associated function objc2::rc::Retained::retain_autoreleased"><code>Retained::retain_autoreleased</code></a>, and a generic <code>Retained&lt;T&gt;</code> or
<code>Option&lt;Retained&lt;T&gt;&gt;</code> is returned. This retain is in most cases faster
than using autorelease pools!</p>
</li>
</ul>
<p>See <a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html#retainable-object-pointers-as-operands-and-arguments">the clang documentation</a> for the precise
specification of Objective-C’s ownership rules.</p>
<p>As you may have noticed, the return type is usually either <code>Retained</code> or
<code>Option&lt;Retained&gt;</code>. Internally, the return type is always
<code>Option&lt;Retained&gt;</code> (for example: almost all <code>new</code> methods can fail if the
allocation failed), but for convenience, if the return type is
<code>Retained&lt;T&gt;</code>, this macro will automatically unwrap the object, or panic
with an error message if it couldn’t be retrieved.</p>
<p>As a special case, if the last argument is the marker <code>_</code>, the macro will
return a <code>Result&lt;Retained&lt;T&gt;, Retained&lt;E&gt;&gt;</code>, see below.</p>
<p>The <code>retain</code>, <code>release</code> and <code>autorelease</code> selectors are not supported, use
<a href="rc/struct.Retained.html#method.retain" title="associated function objc2::rc::Retained::retain"><code>Retained::retain</code></a>, <a href="rc/struct.Retained.html#method.drop" title="method objc2::rc::Retained::drop"><code>Retained::drop</code></a> and <a href="rc/struct.Retained.html#method.autorelease_ptr" title="associated function objc2::rc::Retained::autorelease_ptr"><code>Retained::autorelease_ptr</code></a>
for that.</p>
<h2 id="bool-handling"><a class="doc-anchor" href="#bool-handling">§</a><code>bool</code> handling</h2>
<p>Objective-C’s <code>BOOL</code> is slightly different from Rust’s <a href="https://doc.rust-lang.org/nightly/std/primitive.bool.html" title="primitive bool"><code>bool</code></a>, and hence
a conversion step must be performed before using it. This is <em>very</em> easy
to forget (because it’ll happen to work in <em>most</em> cases), so this macro
does the conversion step automatically whenever an argument or the return
type is <code>bool</code>.</p>
<p>That means that any Objective-C method that take or return <code>BOOL</code> can be
translated to use <code>bool</code> on the Rust side.</p>
<p>If you want to handle the conversion explicitly, or the Objective-C method
expects e.g. a pointer to a <code>BOOL</code>, use <a href="runtime/struct.Bool.html" title="struct objc2::runtime::Bool"><code>runtime::Bool</code></a> instead.</p>
<h2 id="out-parameters"><a class="doc-anchor" href="#out-parameters">§</a>Out-parameters</h2>
<p>Parameters like <code>NSString**</code> in Objective-C are passed by “writeback”,
which means that the callee autoreleases any value that they may write
into the parameter.</p>
<p>This macro has support for passing such parameters using the following
types:</p>
<ul>
<li><code>&amp;mut Retained&lt;_&gt;</code></li>
<li><code>Option&lt;&amp;mut Retained&lt;_&gt;&gt;</code></li>
<li><code>&amp;mut Option&lt;Retained&lt;_&gt;&gt;</code>,</li>
<li><code>Option&lt;&amp;mut Option&lt;Retained&lt;_&gt;&gt;&gt;</code></li>
</ul>
<p>Beware with the first two, since they will cause undefined behaviour if
the method overwrites the value with <code>nil</code>.</p>
<p>See <a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html#passing-to-an-out-parameter-by-writeback">clang’s documentation</a> for more details.</p>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>The most common place you’ll see out-parameters is as <code>NSError**</code> the last
parameter, which is used to communicate errors to the caller, see <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorHandling/ErrorHandling.html">Error
Handling Programming Guide For Cocoa</a>.</p>
<p>Similar to Swift’s <a href="https://developer.apple.com/documentation/swift/about-imported-cocoa-error-parameters">importing of error parameters</a>, this
macro supports an even more convenient version than the out-parameter
support, which transforms methods whose last parameter is <code>NSError**</code> into
the Rust equivalent, the <a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> type.</p>
<p>In particular, if you make the last argument the special marker <code>_</code>, then
the macro will return a <code>Result&lt;R, Retained&lt;E&gt;&gt;</code>. The error type <code>E</code> must
be either <a href="runtime/struct.NSObject.html" title="struct objc2::runtime::NSObject"><code>NSObject</code></a> or <code>objc2_foundation::NSError</code>.</p>
<p>The success type <code>R</code> must be either <code>()</code> or <code>Retained&lt;T&gt;</code>.</p>
<p>At runtime, we create the temporary error variable for you on the stack
and send it as the out-parameter to the method. If the method then returns
<code>NO</code>/<code>false</code>, or in the case of an object pointer, <code>NULL</code>, the error
variable is loaded and returned in <a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>.</p>
<h2 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h2>
<p>Unwinds if the underlying method throws and exception. If the
<code>"catch-all"</code> Cargo feature is enabled, the Objective-C exception is
converted into a Rust panic, with potentially a bit better stack trace.</p>
<p>Finally, panics if the return type is specified as <code>Retained&lt;_&gt;</code>, but the
method actually returned NULL. If this happens, you should change the
signature to instead return <code>Option&lt;Retained&lt;_&gt;&gt;</code> to handle the error
yourself.</p>
<h3 id="type-verification"><a class="doc-anchor" href="#type-verification">§</a>Type verification</h3>
<p>To make message sending safer, all arguments and return values for
messages must implement <a href="encode/trait.Encode.html" title="trait objc2::encode::Encode"><code>encode::Encode</code></a>. This allows the Rust compiler
to prevent you from passing e.g. a <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> into Objective-C, which would
both be UB and leak the vector.</p>
<p>When <code>debug_assertions</code> are enabled, this macro will check the encoding of
the given arguments and return every time you send a message, and will
panic if they are not equivalent.</p>
<p>This is not a perfect solution for ensuring safety (some Rust types have
the same Objective-C encoding, but are not equivalent, such as <code>&amp;T</code> and
<code>*const T</code>), but it gets us much closer to it!</p>
<p>This behaviour can be tweaked with the <code>"relax-void-encoding"</code>,
<code>"relax-sign-encoding"</code> or <code>"disable-encoding-assertions"</code> Cargo feature
flags if it is causing you trouble.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Similar to defining and calling an <code>extern</code> function in a foreign function
interface. In particular, you must uphold the following requirements:</p>
<ol>
<li>
<p>The selector corresponds to a valid method that is available on the
receiver.</p>
</li>
<li>
<p>The argument types match what the receiver excepts for this selector.</p>
</li>
<li>
<p>The return type match what the receiver returns for this selector.</p>
</li>
<li>
<p>The call must not violate Rust’s mutability rules, for example if
passing an <code>&amp;T</code>, the Objective-C method must not mutate the variable
(except if the variable is inside <a href="https://doc.rust-lang.org/nightly/core/cell/struct.UnsafeCell.html" title="struct core::cell::UnsafeCell"><code>std::cell::UnsafeCell</code></a> or
derivatives).</p>
</li>
<li>
<p>If the receiver is a raw pointer it must be valid (aligned,
dereferenceable, initialized and so on). Messages to <code>null</code> pointers
are allowed (though heavily discouraged), but <em>only</em> if the return type
itself is a pointer.</p>
</li>
<li>
<p>You must uphold any additional safety requirements (explicit and
implicit) that the method has. For example:</p>
<ul>
<li>Methods that take pointers usually require that the pointer is valid,
and sometimes non-null.</li>
<li>Sometimes, a method may only be called on the main thread.</li>
<li>The lifetime of returned pointers usually follows certain rules, and
may not be valid outside of an <a href="rc/fn.autoreleasepool.html" title="fn objc2::rc::autoreleasepool"><code>autoreleasepool</code></a> (returning
<code>Retained</code> usually helps with these cases).</li>
</ul>
</li>
<li>
<p>Each out-parameter must have the correct nullability, and the method
must not have any attributes that changes the how it handles memory
management for these.</p>
</li>
<li>
<p>If using the automatic memory management facilities of this macro, the
method must not have any attributes such as <code>objc_method_family</code>,
<code>ns_returns_retained</code>, <code>ns_consumed</code> that changes the how it handles
memory management.</p>
</li>
<li>
<p>TODO: Maybe more?</p>
</li>
</ol>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Interacting with <a href="https://developer.apple.com/documentation/foundation/nsurlcomponents?language=objc"><code>NSURLComponents</code></a>, <a href="https://developer.apple.com/documentation/foundation/nsstring?language=objc"><code>NSString</code></a> and <a href="https://developer.apple.com/documentation/foundation/nsnumber?language=objc"><code>NSNumber</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2::rc::Retained;
<span class="kw">use </span>objc2::{msg_send, ClassType};
<span class="kw">use </span>objc2_foundation::{NSNumber, NSString, NSURLComponents};


<span class="comment">// Create an empty `NSURLComponents` by calling the class method `new`.
</span><span class="kw">let </span>components: Retained&lt;NSURLComponents&gt; = <span class="kw">unsafe </span>{
    <span class="comment">//          ^^^^^^^^^^^^^^^^^^^^^^^^^ the return type, a memory-managed
    //                                    `NSURLComponents` instance
    //
    </span><span class="macro">msg_send!</span>[NSURLComponents::class(), new]
    <span class="comment">//        ------------------------  ^^^ the selector `new`
    //        |
    //        the receiver, in this case the class itself
</span>};


<span class="comment">// Create a new `NSNumber` from an integer.
</span><span class="kw">let </span>port: Retained&lt;NSNumber&gt; = <span class="kw">unsafe </span>{
    <span class="macro">msg_send!</span>[NSNumber::class(), numberWithInt: <span class="number">8080i32</span>]
    <span class="comment">//                           -------------- ^^^^^^^ the argument to the method
    //                           |
    //                           the selector `numberWithInt:`
    //
    // Note how we must fully specify the argument as `8080i32` instead of just `8080`.
</span>};


<span class="comment">// Set the port property of the URL.
</span><span class="kw">let _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>components, setPort: <span class="kw-2">&amp;*</span>port] };
<span class="comment">//     --                                   -------- ^^^^^^ the port is deref'd to
//     |                                    |               become the correct type
//     |                                    |
//     |                                    the selector `setPort:` is derived
//     |                                    from the property name `port`.
//     |
//     return type (i.e. nothing / void)
//
// Note that even return types of `void` must be explicitly specified as `()`.


// Set the `host` property of the URL.
</span><span class="kw">let </span>host: Retained&lt;NSString&gt; = <span class="kw">unsafe </span>{
    <span class="macro">msg_send!</span>[NSString::class(), stringWithUTF8String: <span class="string">c"example.com"</span>.as_ptr()]
};
<span class="kw">let _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>components, setHost: <span class="kw-2">&amp;*</span>host] };


<span class="comment">// Set the `scheme` property of the URL.
</span><span class="kw">let </span>scheme: Retained&lt;NSString&gt; = <span class="kw">unsafe </span>{
    <span class="macro">msg_send!</span>[NSString::class(), stringWithUTF8String: <span class="string">c"http"</span>.as_ptr()]
};
<span class="kw">let _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>components, setScheme: <span class="kw-2">&amp;*</span>scheme] };


<span class="comment">// Get the combined URL in string form.
</span><span class="kw">let </span>string: <span class="prelude-ty">Option</span>&lt;Retained&lt;NSString&gt;&gt; = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>components, string] };
<span class="comment">//          ^^^^^^ the method can return NULL, so we specify an option here


</span><span class="macro">assert_eq!</span>(string.unwrap().to_string(), <span class="string">"http://example.com:8080"</span>);</code></pre></div>
<p>The example above uses only <code>msg_send!</code> for demonstration purposes; note
that usually the interface you seek is already present in <a href="topics/about_generated/index.html" title="mod objc2::topics::about_generated">the framework
crates</a> and then the equivalent code can be as simple as:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2_foundation::{NSNumber, NSString, NSURLComponents};

<span class="kw">let </span>components = <span class="kw">unsafe </span>{ NSURLComponents::new() };
<span class="kw">unsafe </span>{ components.setPort(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>NSNumber::new_i32(<span class="number">8080</span>))) };
<span class="kw">unsafe </span>{ components.setHost(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>NSString::from_str(<span class="string">"example.com"</span>))) };
<span class="kw">unsafe </span>{ components.setScheme(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>NSString::from_str(<span class="string">"http"</span>))) };
<span class="kw">let </span>string = <span class="kw">unsafe </span>{ components.string() };

<span class="macro">assert_eq!</span>(string.unwrap().to_string(), <span class="string">"http://example.com:8080"</span>);</code></pre></div>
<p>Sending messages to the superclass of an object.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2::runtime::NSObject;
<span class="kw">use </span>objc2::{msg_send, ClassType};

<span class="comment">// Call `someMethod` on the direct super class.
</span><span class="kw">let _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw">super</span>(<span class="kw-2">&amp;</span>obj), someMethod] };

<span class="comment">// Or lower-level, a method on a specific superclass.
</span><span class="kw">let </span>superclass = NSObject::class();
<span class="kw">let </span>arg3: u32 = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw">super</span>(<span class="kw-2">&amp;</span>obj, superclass), getArg3] };</code></pre></div>
<p>Sending a message with automatic error handling.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2::msg_send;
<span class="kw">use </span>objc2::rc::Retained;
<span class="kw">use </span>objc2_foundation::{NSBundle, NSError};

<span class="kw">let </span>bundle = NSBundle::mainBundle();

<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;(), Retained&lt;NSError&gt;&gt; = <span class="kw">unsafe </span>{
    <span class="comment">//          --  -------- ^^^^^^^ must be NSError or NSObject
    //          |   |
    //          |   always retained
    //          |
    //          `()` means that the method returns `bool`, we check
    //          that and return success if `true`, an error if `false`
    //
    </span><span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>bundle, preflightAndReturnError: <span class="kw">_</span>]
    <span class="comment">//                                          ^ activate error handling
</span>};</code></pre></div>
<p>Sending a message with an out parameter <em>and</em> automatic error handling.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2::msg_send;
<span class="kw">use </span>objc2::rc::Retained;

<span class="kw">let </span>obj: <span class="kw-2">&amp;</span>NSFileManager;
<span class="kw">let </span>url: <span class="kw-2">&amp;</span>NSURL;
<span class="kw">let </span><span class="kw-2">mut </span>result_url: <span class="prelude-ty">Option</span>&lt;Retained&lt;NSURL&gt;&gt; = <span class="prelude-val">None</span>;
<span class="kw">unsafe </span>{
    <span class="macro">msg_send!</span>[
        obj,
        trashItemAtURL: url,
        resultingItemURL: <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span>result_url),
        error: <span class="kw">_
    </span>]<span class="question-mark">?
</span><span class="comment">//   ^ is possible on error-returning methods, if the return type is specified
</span>};

<span class="comment">// Use `result_url` here
</span></code></pre></div>
<p>Attempt to do an invalid message send. This is undefined behaviour, but
will panic with <code>debug_assertions</code> enabled.</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>objc2::msg_send;
<span class="kw">use </span>objc2::runtime::NSObject;

<span class="kw">let </span>obj = NSObject::new();

<span class="comment">// Wrong return type - this is UB!
//
// But it will be caught with `debug_assertions` enabled, stating that
// the return type's encoding is not correct.
</span><span class="kw">let </span>hash: f32 = <span class="kw">unsafe </span>{ <span class="macro">msg_send!</span>[<span class="kw-2">&amp;</span>obj, hash] };</code></pre></div></div></details></section></div></main></body></html>